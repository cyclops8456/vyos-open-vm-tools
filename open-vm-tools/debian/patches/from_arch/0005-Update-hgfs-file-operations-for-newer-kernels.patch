From c1a0f4254812d3588b3716204190a521e8f87db8 Mon Sep 17 00:00:00 2001
From: "Scott M. Kroll" <skroll@gmail.com>
Date: Mon, 14 Jul 2014 12:42:06 -0400
Subject: [PATCH 5/5] Update hgfs file operations for newer kernels

* Keep track of write back pages so concurrent file validations do not
  invalidate the cache.
* Handle file flush operations.
---
 open-vm-tools/modules/linux/vmhgfs/file.c       | 210 +++++-
 open-vm-tools/modules/linux/vmhgfs/fsutil.c     | 743 ++++++++++++++++----
 open-vm-tools/modules/linux/vmhgfs/inode.c      |  66 +-
 open-vm-tools/modules/linux/vmhgfs/module.h     |   7 +
 open-vm-tools/modules/linux/vmhgfs/page.c       | 862 ++++++++++++++++++++++--
 8 files changed, 1735 insertions(+), 315 deletions(-)

diff --git a/modules/linux/vmhgfs/file.c b/modules/linux/vmhgfs/file.c
index 3568f4a..825cebe 100644
--- a/modules/linux/vmhgfs/file.c
+++ b/modules/linux/vmhgfs/file.c
@@ -47,6 +47,21 @@
 #include "vm_assert.h"
 #include "vm_basic_types.h"
 
+/*
+ * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using
+ * the O_SYNC flag.  We continue to use the existing numerical value
+ * for O_DSYNC semantics now, but using the correct symbolic name for it.
+ * This new value is used to request true Posix O_SYNC semantics.  It is
+ * defined in this strange way to make sure applications compiled against
+ * new headers get at least O_DSYNC semantics on older kernels.
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#define HGFS_FILECTL_SYNC(flags)            ((flags) & O_DSYNC)
+#else
+#define HGFS_FILECTL_SYNC(flags)            ((flags) & O_SYNC)
+#endif
+
 /* Private functions. */
 static int HgfsPackOpenRequest(struct inode *inode,
                                struct file *file,
@@ -85,6 +100,16 @@
                        loff_t  offset,
                        int origin);
 
+static int HgfsFlush(struct file *file
+#if !defined VMW_FLUSH_HAS_1_ARG
+                     ,fl_owner_t id
+#endif
+                    );
+
+#if !defined VMW_FSYNC_31
+static int HgfsDoFsync(struct inode *inode);
+#endif
+
 static int HgfsFsync(struct file *file,
 #if defined VMW_FSYNC_OLD
                      struct dentry *dentry,
@@ -126,7 +151,10 @@
    .owner      = THIS_MODULE,
    .open       = HgfsOpen,
    .llseek     = HgfsSeek,
+   .flush      = HgfsFlush,
 #if defined VMW_USE_AIO
+   .read       = do_sync_read,
+   .write      = do_sync_write,
    .aio_read   = HgfsAioRead,
    .aio_write  = HgfsAioWrite,
 #else
@@ -797,22 +825,63 @@
              loff_t offset)           // IN:  Offset at which to read
 {
    int result;
+   struct dentry *writeDentry;
+   HgfsInodeInfo *iinfo;
 
    ASSERT(iocb);
    ASSERT(iocb->ki_filp);
    ASSERT(iocb->ki_filp->f_dentry);
    ASSERT(iov);
 
-   LOG(6, (KERN_DEBUG "VMware hgfs: HgfsAioWrite: was called\n"));
+   writeDentry = iocb->ki_filp->f_dentry;
+   iinfo = INODE_GET_II_P(writeDentry->d_inode);
 
-   result = HgfsRevalidate(iocb->ki_filp->f_dentry);
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsAioWrite(%s/%s, %lu@%Ld)\n",
+          writeDentry->d_parent->d_name.name, writeDentry->d_name.name,
+          (unsigned long) iov_length(iov, numSegs), (long long) offset));
+
+   spin_lock(&writeDentry->d_inode->i_lock);
+   /*
+    * Guard against dentry revalidation invalidating the inode underneath us.
+    *
+    * Data is being written and may have valid data in a page in the cache.
+    * This action prevents any invalidating of the inode when a flushing of
+    * cache data occurs prior to syncing the file with the server's attributes.
+    * The flushing of cache data would empty our in memory write pages list and
+    * would cause the inode modified write time to be updated and so the inode
+    * would also be invalidated.
+    */
+   iinfo->numWbPages++;
+   spin_unlock(&writeDentry->d_inode->i_lock);
+
+   result = HgfsRevalidate(writeDentry);
    if (result) {
       LOG(4, (KERN_DEBUG "VMware hgfs: HgfsAioWrite: invalid dentry\n"));
       goto out;
    }
 
    result = generic_file_aio_write(iocb, iov, numSegs, offset);
-  out:
+
+   if (result >= 0) {
+      if (IS_SYNC(writeDentry->d_inode) ||
+          HGFS_FILECTL_SYNC(iocb->ki_filp->f_flags)) {
+         int error;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+         error = vfs_fsync(iocb->ki_filp, 0);
+#else
+         error = HgfsDoFsync(writeDentry->d_inode);
+#endif
+
+         if (error < 0) {
+            result = error;
+         }
+      }
+   }
+
+out:
+   spin_lock(&writeDentry->d_inode->i_lock);
+   iinfo->numWbPages--;
+   spin_unlock(&writeDentry->d_inode->i_lock);  
    return result;
 }
 
@@ -961,6 +1030,97 @@
    return result;
 }
 
+#if !defined VMW_FSYNC_31
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsDoFsync --
+ *
+ *    Helper for HgfsFlush() and HgfsFsync().
+ *
+ *    The hgfs protocol doesn't support fsync explicityly yet.
+ *    So for now, we flush all the pages to presumably honor the
+ *    intent of an app calling fsync() which is to get the
+ *    data onto persistent storage. As things stand now we're at
+ *    the whim of the hgfs server code running on the host to fsync or
+ *    not if and when it pleases.
+ *
+ *
+ * Results:
+ *    Returns zero on success. Otherwise an error.
+ *
+ * Side effects:
+ *    None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+HgfsDoFsync(struct inode *inode)            // IN: File we operate on
+{
+   int ret;
+
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsDoFsync(%"FMT64"u)\n",
+            INODE_GET_II_P(inode)->hostFileId));
+
+   ret = compat_filemap_write_and_wait(inode->i_mapping);
+
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsDoFsync: returns %d\n", ret));
+
+   return ret;
+}
+#endif
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsFlush --
+ *
+ *    Called when user process calls fflush() on an hgfs file.
+ *    Flush all dirty pages and check for write errors.
+ *
+ *
+ * Results:
+ *    Returns zero on success. (Currently always succeeds).
+ *
+ * Side effects:
+ *    None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+HgfsFlush(struct file *file                        // IN: file to flush
+#if !defined VMW_FLUSH_HAS_1_ARG
+          ,fl_owner_t id                           // IN: id not used
+#endif
+         )
+{
+   int ret = 0;
+
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsFlush(%s/%s)\n",
+            file->f_dentry->d_parent->d_name.name,
+            file->f_dentry->d_name.name));
+
+   if ((file->f_mode & FMODE_WRITE) == 0) {
+      goto exit;
+   }
+
+
+   /* Flush writes to the server and return any errors */
+   LOG(6, (KERN_DEBUG "VMware hgfs: HgfsFlush: calling vfs_sync ... \n"));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+   ret = vfs_fsync(file, 0);
+#else
+   ret = HgfsDoFsync(file->f_dentry->d_inode);
+#endif
+
+exit:
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsFlush: returns %d\n", ret));
+   return ret;
+}
+
 
 /*
  *----------------------------------------------------------------------
@@ -1003,9 +1163,36 @@
 #endif
           int datasync)	                // IN: fdatasync or fsync
 {
-   LOG(6, (KERN_DEBUG "VMware hgfs: HgfsFsync: was called\n"));
+   int ret = 0;
+   loff_t startRange;
+   loff_t endRange;
+   struct inode *inode;
+
+#if defined VMW_FSYNC_31
+   startRange = start;
+   endRange = end;
+#else
+   startRange = 0;
+   endRange = MAX_INT64;
+#endif
+ 
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsFsync(%s/%s, %lld, %lld, %d)\n",
+           file->f_dentry->d_parent->d_name.name,
+           file->f_dentry->d_name.name,
+           startRange, endRange,
+           datasync));
+
+   /* Flush writes to the server and return any errors */
+   inode = file->f_dentry->d_inode;
+#if defined VMW_FSYNC_31
+   ret = filemap_write_and_wait_range(inode->i_mapping, startRange, endRange);
+#else
+   ret = HgfsDoFsync(inode);
+#endif
 
-   return 0;
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsFsync: written pages  %lld, %lld returns %d)\n",
+           startRange, endRange, ret));
+   return ret;
 }
 
 

diff --git a/modules/linux/vmhgfs/fsutil.c b/modules/linux/vmhgfs/fsutil.c
index 1028cc9..72f81f1 100644
--- a/modules/linux/vmhgfs/fsutil.c
+++ b/modules/linux/vmhgfs/fsutil.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2006 VMware, Inc. All rights reserved.
+ * Copyright (C) 2006-2014 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -649,7 +649,8 @@
          attrInfo->groupId = attrV2->groupId;
          attrInfo->mask |= HGFS_ATTR_VALID_GROUPID;
       }
-      if (attrV2->mask & HGFS_ATTR_VALID_FILEID) {
+      if (attrV2->mask & (HGFS_ATTR_VALID_FILEID |
+                          HGFS_ATTR_VALID_NON_STATIC_FILEID)) {
          attrInfo->hostFileId = attrV2->hostFileId;
          attrInfo->mask |= HGFS_ATTR_VALID_FILEID;
       }
@@ -717,6 +718,15 @@
 }
 #endif
 
+static inline int
+hgfs_timespec_compare(const struct timespec *lhs, const struct timespec *rhs)
+{
+   if (lhs->tv_sec < rhs->tv_sec)
+      return -1;
+   if (lhs->tv_sec > rhs->tv_sec)
+      return 1;
+   return lhs->tv_nsec - rhs->tv_nsec;
+}
 
 /*
  *----------------------------------------------------------------------
@@ -780,6 +790,73 @@
    }
 }
 
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * HgfsIsInodeWritable --
+ *
+ *      Helper function for verifying if a file is under write access.
+ *
+ * Results:
+ *      TRUE if file is writable, FALSE otherwise.
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static Bool
+HgfsIsInodeWritable(struct inode *inode) // IN: File we're writing to
+{
+   HgfsInodeInfo *iinfo;
+   struct list_head *cur;
+   Bool isWritable = FALSE;
+
+   iinfo = INODE_GET_II_P(inode);
+   /*
+    * Iterate over the open handles for this inode, and find if there
+    * is one that allows the write mode.
+    * Note, the mode is stored as incremented by one to prevent overload of
+    * the zero value.
+    */
+   spin_lock(&hgfsBigLock);
+   list_for_each(cur, &iinfo->files) {
+      HgfsFileInfo *finfo = list_entry(cur, HgfsFileInfo, list);
+
+      if (0 != (finfo->mode & (HGFS_OPEN_MODE_WRITE_ONLY + 1))) {
+         isWritable = TRUE;
+         break;
+      }
+   }
+   spin_unlock(&hgfsBigLock);
+
+   return isWritable;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * HgfsIsSafeToChange --
+ *
+ *      Helper function for verifying if a file inode size and time fields is safe
+ *      to update. It is deemed safe only if there is not an open writer to the file.
+ *
+ * Results:
+ *      TRUE if safe to change inode, FALSE otherwise.
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static Bool
+HgfsIsSafeToChange(struct inode *inode) // IN: File we're writing to
+{
+   return !HgfsIsInodeWritable(inode);
+}
 
 /*
  *----------------------------------------------------------------------
@@ -805,13 +882,34 @@
                          HgfsAttrInfo const *attr)     // IN: New attrs
 {
    HgfsSuperInfo *si;
+   HgfsInodeInfo *iinfo;
    Bool needInvalidate = FALSE;
+   Bool isSafeToChange;
 
    ASSERT(inode);
    ASSERT(inode->i_sb);
    ASSERT(attr);
 
    si = HGFS_SB_TO_COMMON(inode->i_sb);
+   iinfo = INODE_GET_II_P(inode);
+
+   /*
+    * We do not want to update the file size from server or invalidate the inode
+    * for inodes open for write. We need to avoid races with the write page
+    * extending the file. This also will cause the server to possibly update the
+    * server side file's mod time too. For those situations we do not want to blindly
+    * go and invalidate the inode pages thus losing changes in flight and corrupting the
+    * file.
+    * We only need to invalidate the inode pages if the file has truly been modified
+    * on the server side by another server side application, not by our writes.
+    * If there are no writers it is safe to assume that newer mod time means the file
+    * changed on the server side underneath us.
+    */
+   isSafeToChange = HgfsIsSafeToChange(inode);
+
+   spin_lock(&inode->i_lock);
+
+   iinfo = INODE_GET_II_P(inode);
 
    LOG(6, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: entered\n"));
    HgfsSetFileType(inode, attr);
@@ -882,21 +980,23 @@
 
    /*
     * Invalidate cached pages if we didn't receive the file size, or if it has
-    * changed on the server.
+    * changed on the server, and no writes in flight.
     */
    if (attr->mask & HGFS_ATTR_VALID_SIZE) {
       loff_t oldSize = compat_i_size_read(inode);
       inode->i_blocks = HgfsCalcBlockSize(attr->size);
       if (oldSize != attr->size) {
-         LOG(4, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: new file "
-                 "size: %"FMT64"u, old file size: %Lu\n", attr->size, oldSize));
-         needInvalidate = TRUE;
+         if (oldSize < attr->size || (iinfo->numWbPages == 0 && isSafeToChange)) {
+            needInvalidate = TRUE;
+            LOG(4, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: new file "
+                    "size: %"FMT64"u, old file size: %Lu\n", attr->size, oldSize));
+            inode->i_blocks = HgfsCalcBlockSize(attr->size);
+            compat_i_size_write(inode, attr->size);
+         }
       }
-      compat_i_size_write(inode, attr->size);
    } else {
       LOG(4, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: did not "
               "get file size\n"));
-      needInvalidate = TRUE;
    }
 
    if (attr->mask & HGFS_ATTR_VALID_ACCESS_TIME) {
@@ -907,12 +1007,15 @@
 
    /*
     * Invalidate cached pages if we didn't receive the modification time, or if
-    * it has changed on the server.
+    * it has changed on the server and we don't have writes in flight and any open
+    * open writers.
     */
    if (attr->mask & HGFS_ATTR_VALID_WRITE_TIME) {
       HGFS_DECLARE_TIME(newTime);
       HGFS_SET_TIME(newTime, attr->writeTime);
-      if (!HGFS_EQUAL_TIME(newTime, inode->i_mtime)) {
+      if (hgfs_timespec_compare(&newTime, &inode->i_mtime) > 0 &&
+          iinfo->numWbPages == 0 &&
+          isSafeToChange) {
          LOG(4, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: new mod "
                  "time: %ld:%lu, old mod time: %ld:%lu\n",
                  HGFS_PRINT_TIME(newTime), HGFS_PRINT_TIME(inode->i_mtime)));
@@ -920,7 +1023,6 @@
       }
       HGFS_SET_TIME(inode->i_mtime, attr->writeTime);
    } else {
-      needInvalidate = TRUE;
       LOG(4, (KERN_DEBUG "VMware hgfs: HgfsChangeFileAttributes: did not "
               "get mod time\n"));
       HGFS_SET_TIME(inode->i_mtime, HGFS_GET_CURRENT_TIME());
@@ -938,6 +1040,8 @@
       HGFS_SET_TIME(inode->i_ctime, HGFS_GET_CURRENT_TIME());
    }
 
+   spin_unlock(&inode->i_lock);
+   
    /*
     * Compare old size and write time with new size and write time. If there's
     * a difference (or if we didn't get a new size or write time), the file
@@ -1711,7 +1815,7 @@
 /*
  *-----------------------------------------------------------------------------
  *
- * HgfsDentryAgeReset --
+ * HgfsDentryAgeForce --
  *
  *    Set the dentry's time to 0. This makes the dentry's age "too old" and
  *    forces subsequent HgfsRevalidates to go to the server for attributes.
@@ -2218,5 +2322,7 @@
    iinfo->isReferencedInode = FALSE;
    iinfo->isFakeInodeNumber = FALSE;
    iinfo->createdAndUnopened = FALSE;
+   iinfo->numWbPages = 0;
+   INIT_LIST_HEAD(&iinfo->listWbPages);
 
 }
diff --git a/modules/linux/vmhgfs/inode.c b/modules/linux/vmhgfs/inode.c
index caaa41a..93e28bf 100644
--- a/modules/linux/vmhgfs/inode.c
+++ b/modules/linux/vmhgfs/inode.c
@@ -162,6 +162,36 @@
 /*
  *----------------------------------------------------------------------
  *
+ * HgfsClearReadOnly --
+ *
+ *    Try to remove the file/dir read only attribute.
+ *
+ *    Note when running on Windows servers the entry may have the read-only
+ *    flag set and prevent a rename or delete operation from occuring.
+ *
+ * Results:
+ *    Returns zero on success, or a negative error on failure.
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+HgfsClearReadOnly(struct dentry *dentry)  // IN: file/dir to remove read only
+{
+   struct iattr enableWrite;
+
+   LOG(4, (KERN_DEBUG "VMware hgfs: HgfsClearReadOnly: removing read-only\n"));
+   enableWrite.ia_mode = (dentry->d_inode->i_mode | S_IWUSR);
+   enableWrite.ia_valid = ATTR_MODE;
+   return HgfsSetattr(dentry, &enableWrite);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
  * HgfsDelete --
  *
  *    Handle both unlink and rmdir requests.
@@ -309,14 +339,9 @@
           * safe?
           */
          if (!secondAttempt) {
-            struct iattr enableWrite;
             secondAttempt = TRUE;
 
-            LOG(4, (KERN_DEBUG "VMware hgfs: HgfsDelete: access denied, "
-                    "attempting to work around read-only bit\n"));
-            enableWrite.ia_mode = (dentry->d_inode->i_mode | S_IWUSR);
-            enableWrite.ia_valid = ATTR_MODE;
-            result = HgfsSetattr(dentry, &enableWrite);
+            result = HgfsClearReadOnly(dentry);
             if (result == 0) {
                LOG(4, (KERN_DEBUG "VMware hgfs: HgfsDelete: file is no "
                        "longer read-only, retrying delete\n"));
@@ -1336,6 +1361,7 @@
    HgfsReq *req = NULL;
    char *oldName;
    char *newName;
+   Bool secondAttempt=FALSE;
    uint32 *oldNameLength;
    uint32 *newNameLength;
    int result = 0;
@@ -1500,6 +1526,31 @@
                     "returned error: %d\n", result));
             goto out;
          }
+      } else if ((-EACCES == result) || (-EPERM == result)) {
+         /*
+          * It's possible that we're talking to a Windows server with
+          * a file marked read-only. Let's try again, after removing
+          * the read-only bit from the file.
+          *
+          * XXX: I think old servers will send -EPERM here. Is this entirely
+          * safe?
+          */
+         if (!secondAttempt) {
+            secondAttempt = TRUE;
+            result = HgfsClearReadOnly(newDentry);
+            if (result == 0) {
+               LOG(4, (KERN_DEBUG "VMware hgfs: HgfsRename: file is no "
+                       "longer read-only, retrying rename\n"));
+               goto retry;
+            }
+            LOG(4, (KERN_DEBUG "VMware hgfs: HgfsRename: failed to remove "
+                    "read-only property\n"));
+         } else {
+            LOG(4, (KERN_DEBUG "VMware hgfs: HgfsRename: second attempt at "
+                    "rename failed\n"));
+         }
+      } else if (0 != result) {
+         LOG(4, (KERN_DEBUG "VMware hgfs: HgfsRename: failed with result %d\n", result));
       }
    } else if (result == -EIO) {
       LOG(4, (KERN_DEBUG "VMware hgfs: HgfsRename: timed out\n"));
diff --git a/modules/linux/vmhgfs/module.h b/modules/linux/vmhgfs/module.h
index b6bcd1e..0c0a842 100644
--- a/modules/linux/vmhgfs/module.h
+++ b/modules/linux/vmhgfs/module.h
@@ -147,6 +147,13 @@ typedef struct HgfsInodeInfo {
    /* Is this a fake inode created in HgfsCreate that has yet to be opened? */
    Bool createdAndUnopened;
 
+   /*
+    * The number of write back pages to the file which is tracked so any
+    * concurrent file validations such as reads will not invalidate the cache.
+    */
+   unsigned long numWbPages;
+   struct list_head listWbPages;
+
    /* Is this inode referenced by HGFS? (needed by HgfsInodeLookup()) */
    Bool isReferencedInode;
 
diff --git a/modules/linux/vmhgfs/page.c b/modules/linux/vmhgfs/page.c
index 6d8b50f..cf3b8c9 100644
--- a/modules/linux/vmhgfs/page.c
+++ b/modules/linux/vmhgfs/page.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2006 VMware, Inc. All rights reserved.
+ * Copyright (C) 2006-2014 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -64,15 +64,18 @@
                            struct page *page,
                            unsigned pageFrom,
                            unsigned pageTo);
-static void HgfsDoWriteBegin(struct page *page,
-                             unsigned pageFrom,
-                             unsigned pageTo);
+static int HgfsDoWriteBegin(struct file *file,
+                            struct page *page,
+                            unsigned pageFrom,
+                            unsigned pageTo);
 static int HgfsDoWriteEnd(struct file *file,
                           struct page *page,
                           unsigned pageFrom,
                           unsigned pageTo,
                           loff_t writeTo,
                           unsigned copied);
+static void HgfsDoExtendFile(struct inode *inode,
+                             loff_t writeTo);
 
 /* HGFS address space operations. */
 static int HgfsReadpage(struct file *file,
@@ -128,6 +131,26 @@
    .set_page_dirty = __set_page_dirty_nobuffers,
 };
 
+enum {
+   PG_BUSY = 0,
+};
+
+typedef struct HgfsWbPage {
+   struct list_head        wb_list;        /* Defines state of page: */
+   struct page             *wb_page;       /* page to read in/write out */
+   pgoff_t                 wb_index;       /* Offset >> PAGE_CACHE_SHIFT */
+   struct kref             wb_kref;        /* reference count */
+   unsigned long           wb_flags;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 13)
+   wait_queue_head_t       wb_queue;
+#endif
+} HgfsWbPage;
+
+static void HgfsInodePageWbAdd(struct inode *inode,
+                                struct page *page);
+static void HgfsInodePageWbRemove(struct inode *inode,
+                                  struct page *page);
+static void HgfsWbRequestDestroy(HgfsWbPage *req);
 
 /*
  * Private functions.
@@ -690,11 +713,11 @@
       pageFrom += result;
 
       /* Update the inode's size now rather than waiting for a revalidate. */
-      if (curOffset > compat_i_size_read(inode)) {
-         compat_i_size_write(inode, curOffset);
-      }
+      HgfsDoExtendFile(inode, curOffset);
    } while ((result > 0) && (remainingCount > 0));
 
+   HgfsInodePageWbRemove(inode, page);
+   
    result = 0;
 
   out:
@@ -866,7 +889,7 @@
  *      Initialize the page if the file is to be appended.
  *
  * Results:
- *      None.
+ *      Zero on success, always.
  *
  * Side effects:
  *      None.
@@ -874,37 +897,35 @@
  *-----------------------------------------------------------------------------
  */
 
-static void
-HgfsDoWriteBegin(struct page *page,         // IN: Page to be written
+static int
+HgfsDoWriteBegin(struct file *file,         // IN: File to be written
+                 struct page *page,         // IN: Page to be written
                  unsigned pageFrom,         // IN: Starting page offset
                  unsigned pageTo)           // IN: Ending page offset
 {
-   loff_t offset;
-   loff_t currentFileSize;
 
    ASSERT(page);
 
-   offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
-   currentFileSize = compat_i_size_read(page->mapping->host);
-
-   /*
-    * If we are doing a partial write into a new page (beyond end of
-    * file), then intialize it. This allows other writes to this page
-    * to accumulate before we need to write it to the server.
-    */
-   if ((offset >= currentFileSize) ||
-       ((pageFrom == 0) && (offset + pageTo) >= currentFileSize)) {
-      void *kaddr = compat_kmap_atomic(page);
-
-      if (pageFrom) {
+   if (!PageUptodate(page)) {
+      /*
+       * If we are doing a partial write into a new page (beyond end of
+       * file), then intialize it. This allows other writes to this page
+       * to accumulate before we need to write it to the server.
+       */
+      if (pageTo - pageFrom != PAGE_CACHE_SIZE) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+         zero_user_segments(page, 0, pageFrom, pageTo, PAGE_CACHE_SIZE);
+#else
+         void *kaddr = compat_kmap_atomic(page);
          memset(kaddr, 0, pageFrom);
-      }
-      if (pageTo < PAGE_CACHE_SIZE) {
          memset(kaddr + pageTo, 0, PAGE_CACHE_SIZE - pageTo);
+         flush_dcache_page(page);
+         compat_kunmap_atomic(kaddr);
+#endif
       }
-      compat_kunmap_atomic(kaddr);
-      flush_dcache_page(page);
    }
+
+   return 0;
 }
 
 
@@ -928,14 +949,12 @@
  */
 
 static int
-HgfsPrepareWrite(struct file *file,  // IN: Ignored
+HgfsPrepareWrite(struct file *file,  // IN: File to be written
                  struct page *page,  // IN: Page to prepare
                  unsigned pageFrom,  // IN: Beginning page offset
                  unsigned pageTo)    // IN: Ending page offset
 {
-   HgfsDoWriteBegin(page, pageFrom, pageTo);
-
-   return 0;
+   return HgfsDoWriteBegin(file, page, pageFrom, pageTo);
 }
 
 #else
@@ -971,21 +990,64 @@
                void **clientData)             // OUT: Opaque to pass to write_end, unused
 {
    pgoff_t index = pos >> PAGE_CACHE_SHIFT;
-   unsigned pageFrom = pos & (PAGE_CACHE_SHIFT - 1);
-   unsigned pageTo = pos + len;
+   unsigned pageFrom = pos & (PAGE_CACHE_SIZE - 1);
+   unsigned pageTo = pageFrom + len;
    struct page *page;
-
+   int result;
+   
    page = compat_grab_cache_page_write_begin(mapping, index, flags);
    if (page == NULL) {
-      return -ENOMEM;
+      result = -ENOMEM;
+      goto exit;
    }
    *pagePtr = page;
 
-   HgfsDoWriteBegin(page, pageFrom, pageTo);
-   return 0;
+   LOG(6, (KERN_DEBUG "VMware hgfs: HgfsWriteBegin: file size %Lu @ %Lu page %u to %u\n",
+         (loff_t)compat_i_size_read(page->mapping->host),
+         (loff_t)page->index << PAGE_CACHE_SHIFT,
+         pageFrom, pageTo));
+
+   result = HgfsDoWriteBegin(file, page, pageFrom, pageTo);
+   ASSERT(result == 0);
+
+exit:
+   LOG(6, (KERN_DEBUG "VMware hgfs: HgfsWriteBegin: return %d\n", result));
+   return result;
 }
 #endif
 
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * HgfsDoExtendFile --
+ *
+ *      Helper function for extending a file size.
+ *
+ *      This function updates the inode->i_size, under the inode lock.
+ *
+ * Results:
+ *      None.
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static void
+HgfsDoExtendFile(struct inode *inode, // IN: File we're writing to
+                 loff_t writeTo)      // IN: Offset we're written to
+{
+   loff_t currentFileSize;
+
+   spin_lock(&inode->i_lock);
+   currentFileSize = compat_i_size_read(inode);
+
+   if (writeTo > currentFileSize) {
+      compat_i_size_write(inode, writeTo);
+   }
+   spin_unlock(&inode->i_lock);
+}
 
 /*
  *-----------------------------------------------------------------------------
@@ -1014,54 +1076,31 @@
                loff_t writeTo,    // IN: File position to write to
                unsigned copied)   // IN: Number of bytes copied to the page
 {
-   HgfsHandle handle;
    struct inode *inode;
-   loff_t currentFileSize;
-   loff_t offset;
 
    ASSERT(file);
    ASSERT(page);
    inode = page->mapping->host;
-   currentFileSize = compat_i_size_read(inode);
-   offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
-
-   if (writeTo > currentFileSize) {
-      compat_i_size_write(inode, writeTo);
-   }
-
-   /* We wrote a complete page, so it is up to date. */
-   if (copied == PAGE_CACHE_SIZE) {
-      SetPageUptodate(page);
-   }
 
    /*
-    * Check if this is a partial write to a new page, which was
-    * initialized in HgfsDoWriteBegin.
+    * Zero any uninitialised parts of the page, and then mark the page
+    * as up to date if it turns out that we're extending the file.
     */
-   if ((offset >= currentFileSize) ||
-       ((pageFrom == 0) && (writeTo >= currentFileSize))) {
+   if (!PageUptodate(page)) {
       SetPageUptodate(page);
    }
 
    /*
-    * If the page is uptodate, then just mark it dirty and let
-    * the page cache write it when it wants to.
+    * Track the pages being written.
     */
-   if (PageUptodate(page)) {
-      set_page_dirty(page);
-      return 0;
-   }
+   HgfsInodePageWbAdd(inode, page);
 
-   /*
-    * We've recieved a partial write to page that is not uptodate, so
-    * do the write now while the page is still locked.  Another
-    * alternative would be to read the page in HgfsDoWriteBegin, which
-    * would make it uptodate (ie a complete cached page).
-    */
-   handle = FILE_GET_FI_P(file)->handle;
-   LOG(6, (KERN_WARNING "VMware hgfs: %s: writing to handle %u\n", __func__,
-           handle));
-   return HgfsDoWritepage(handle, page, pageFrom, pageTo);
+   HgfsDoExtendFile(inode, writeTo);
+
+   set_page_dirty(page);
+
+   LOG(6, (KERN_WARNING "VMware hgfs: HgfsDoWriteEnd: return 0\n"));
+   return 0;
 }
 
 
@@ -1143,13 +1182,16 @@
              void *clientData)               // IN: From write_begin, unused.
 {
    unsigned pageFrom = pos & (PAGE_CACHE_SIZE - 1);
-   unsigned pageTo = pageFrom + copied;
+   unsigned pageTo = pageFrom + len;
    loff_t writeTo = pos + copied;
    int ret;
 
    ASSERT(file);
    ASSERT(mapping);
    ASSERT(page);
+   if (copied < len) {
+      zero_user_segment(page, pageFrom + copied, pageFrom + len);
+   }
 
    ret = HgfsDoWriteEnd(file, page, pageFrom, pageTo, writeTo, copied);
    if (ret == 0) {
@@ -1161,3 +1203,671 @@
    return ret;
 }
 #endif
+
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbPageAlloc --
+ *
+ *    Allocates a write-back page object.
+ *
+ * Results:
+ *    The write-back page object
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static inline HgfsWbPage *
+HgfsWbPageAlloc(void)
+{
+   return kmalloc(sizeof (HgfsWbPage), GFP_KERNEL);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbPageAlloc --
+ *
+ *    Frees a write-back page object.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+
+static inline void
+HgfsWbPageFree(HgfsWbPage *page)  // IN: request of page data to write
+{
+   ASSERT(page);
+   kfree(page);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestFree --
+ *
+ *    Frees the resources for a write-back page request.
+ *    Calls the request destroy and then frees the object memory.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsWbRequestFree(struct kref *kref)  // IN: ref field request of page data to write
+{
+   HgfsWbPage *req = container_of(kref, HgfsWbPage, wb_kref);
+
+   /* Release write back request page and free it. */
+   HgfsWbRequestDestroy(req);
+   HgfsWbPageFree(req);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestGet --
+ *
+ *    Reference the write-back page request.
+ *    Calls the request destroy and then frees the object memory.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+HgfsWbRequestGet(HgfsWbPage *req)   // IN: request of page data to write
+{
+   kref_get(&req->wb_kref);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestPut --
+ *
+ *    Remove a reference the write-back page request.
+ *    Calls the request free to tear down the object memory if it was the
+ *    final one.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    Destroys the request if last one.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+HgfsWbRequestPut(HgfsWbPage *req)  // IN: request of page data to write
+{
+   kref_put(&req->wb_kref, HgfsWbRequestFree);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestWaitUninterruptible --
+ *
+ *    Sleep function while waiting for requests to complete.
+ *
+ * Results:
+ *    Always zero.
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+static int
+HgfsWbRequestWaitUninterruptible(void *word) // IN:unused
+{
+   io_schedule();
+   return 0;
+}
+#endif
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestWait --
+ *
+ *    Wait for a write-back page request to complete.
+ *    Interruptible by fatal signals only.
+ *    The user is responsible for holding a count on the request.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+
+int
+HgfsWbRequestWait(HgfsWbPage *req)  // IN: request of page data to write
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+   return wait_on_bit(&req->wb_flags,
+                      PG_BUSY,
+                      HgfsWbRequestWaitUninterruptible,
+                      TASK_UNINTERRUPTIBLE);
+#else
+   wait_event(req->wb_queue,
+              !test_bit(PG_BUSY, &req->wb_flags));
+   return 0;
+#endif
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestLock --
+ *
+ *    Lock the write-back page request.
+ *
+ * Results:
+ *    Non-zero if the lock was not already locked
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static inline int
+HgfsWbRequestLock(HgfsWbPage *req)  // IN: request of page data to write
+{
+   return !test_and_set_bit(PG_BUSY, &req->wb_flags);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestUnlock --
+ *
+ *    Unlock the write-back page request.
+ *    Wakes up any waiting threads on the lock.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsWbRequestUnlock(HgfsWbPage *req)  // IN: request of page data to write
+{
+   if (!test_bit(PG_BUSY,&req->wb_flags)) {
+      LOG(6, (KERN_WARNING "VMware Hgfs: HgfsWbRequestUnlock: Invalid unlock attempted\n"));
+      return;
+   }
+   smp_mb__before_clear_bit();
+   clear_bit(PG_BUSY, &req->wb_flags);
+   smp_mb__after_clear_bit();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+   wake_up_bit(&req->wb_flags, PG_BUSY);
+#else
+   wake_up(&req->wb_queue);
+#endif
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestUnlockAndPut --
+ *
+ *    Unlock the write-back page request and removes a reference.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsWbRequestUnlockAndPut(HgfsWbPage *req)  // IN: request of page data to write
+{
+   HgfsWbRequestUnlock(req);
+   HgfsWbRequestPut(req);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestListAdd --
+ *
+ *    Add the write-back page request into the list.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static inline void
+HgfsWbRequestListAdd(HgfsWbPage *req,         // IN: request of page data to write
+                     struct list_head *head)  // IN: list of requests
+{
+   list_add_tail(&req->wb_list, head);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestListRemove --
+ *
+ *    Remove the write-back page request from the list.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static inline void
+HgfsWbRequestListRemove(HgfsWbPage *req)  // IN: request of page data to write
+{
+   if (!list_empty(&req->wb_list)) {
+      list_del_init(&req->wb_list);
+  }
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestCreate --
+ *
+ *    Create the write-back page request.
+ *
+ * Results:
+ *    The new write-back page request.
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+HgfsWbPage *
+HgfsWbRequestCreate(struct page *page)   // IN: page of data to write
+{
+   HgfsWbPage *wbReq;
+   /* try to allocate the request struct */
+   wbReq = HgfsWbPageAlloc();
+   if (wbReq == NULL) {
+      wbReq = ERR_PTR(-ENOMEM);
+      goto exit;
+   }
+
+   /*
+    * Initialize the request struct. Initially, we assume a
+    * long write-back delay. This will be adjusted in
+    * update_nfs_request below if the region is not locked.
+    */
+   wbReq->wb_flags   = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 13)
+   init_waitqueue_head(&wbReq->wb_queue);
+#endif
+   INIT_LIST_HEAD(&wbReq->wb_list);
+   wbReq->wb_page    = page;
+   wbReq->wb_index   = page->index;
+   page_cache_get(page);
+   kref_init(&wbReq->wb_kref);
+
+exit:
+   LOG(6, (KERN_WARNING "VMware hgfs: HgfsWbRequestCreate: (%p, %p)\n",
+          wbReq, page));
+   return wbReq;
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsWbRequestDestroy --
+ *
+ *    Destroys by freeing up all resources allocated to the request.
+ *    Release page associated with a write-back request after it has completed.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsWbRequestDestroy(HgfsWbPage *req) // IN: write page request
+{
+   struct page *page = req->wb_page;
+
+   LOG(6, (KERN_WARNING"VMware hgfs: HgfsWbRequestDestroy: (%p, %p)\n",
+          req, req->wb_page));
+
+   if (page != NULL) {
+      page_cache_release(page);
+      req->wb_page = NULL;
+   }
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodeFindWbRequest --
+ *
+ *    Finds if there is a write-back page request on this inode and returns it.
+ *
+ * Results:
+ *    NULL or the write-back request for the page.
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static HgfsWbPage *
+HgfsInodeFindWbRequest(struct inode *inode, // IN: inode of file to write to
+                       struct page *page)   // IN: page of data to write
+{
+   HgfsInodeInfo *iinfo;
+   HgfsWbPage *req = NULL;
+   HgfsWbPage *cur;
+
+   iinfo = INODE_GET_II_P(inode);
+
+   /* Linearly search the write back list for the correct req */
+   list_for_each_entry(cur, &iinfo->listWbPages, wb_list) {
+      if (cur->wb_page == page) {
+         req = cur;
+         break;
+      }
+   }
+
+   if (req != NULL) {
+      HgfsWbRequestGet(req);
+   }
+
+   return req;
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodeFindExistingWbRequest --
+ *
+ *    Finds if there is a write-back page request on this inode and returns
+ *    locked.
+ *    If the request is busy (locked) then it drops the lock and waits for it
+ *    be not locked and searches the list again.
+ *
+ * Results:
+ *    NULL or the write-back request for the page.
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static HgfsWbPage *
+HgfsInodeFindExistingWbRequest(struct inode *inode, // IN: inode of file to write to
+                               struct page *page)   // IN: page of data to write
+{
+   HgfsWbPage *req;
+   int error;
+
+   spin_lock(&inode->i_lock);
+
+   for (;;) {
+      req = HgfsInodeFindWbRequest(inode, page);
+      if (req == NULL) {
+         goto out_exit;
+      }
+
+      /*
+       * Try and lock the request if not already locked.
+       * If we find it is already locked, busy, then we drop
+       * the reference and wait to try again. Otherwise,
+       * once newly locked we break out and return to the caller.
+       */
+      if (HgfsWbRequestLock(req)) {
+         break;
+      }
+
+      /* The request was in use, so wait and then retry */
+      spin_unlock(&inode->i_lock);
+      error = HgfsWbRequestWait(req);
+      HgfsWbRequestPut(req);
+      if (error != 0) {
+         goto out_nolock;
+      }
+
+      spin_lock(&inode->i_lock);
+   }
+
+out_exit:
+   spin_unlock(&inode->i_lock);
+   return req;
+
+out_nolock:
+   return ERR_PTR(error);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodeAddWbRequest --
+ *
+ *    Add a write-back page request to an inode.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsInodeAddWbRequest(struct inode *inode, // IN: inode of file to write to
+                      HgfsWbPage *req)     // IN: page write request
+{
+   HgfsInodeInfo *iinfo = INODE_GET_II_P(inode);
+
+   LOG(6, (KERN_WARNING "VMware hgfs: HgfsInodeAddWbRequest: (%p, %p, %lu)\n",
+          inode, req->wb_page, iinfo->numWbPages));
+
+   /* Lock the request! */
+   HgfsWbRequestLock(req);
+
+   HgfsWbRequestListAdd(req, &iinfo->listWbPages);
+   iinfo->numWbPages++;
+   HgfsWbRequestGet(req);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodeAddWbRequest --
+ *
+ *    Remove a write-back page request from an inode.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsInodeRemoveWbRequest(struct inode *inode, // IN: inode of file written to
+                         HgfsWbPage *req)     // IN: page write request
+{
+   HgfsInodeInfo *iinfo = INODE_GET_II_P(inode);
+
+   LOG(6, (KERN_CRIT "VMware hgfs: HgfsInodeRemoveWbRequest: (%p, %p, %lu)\n",
+          inode, req->wb_page, iinfo->numWbPages));
+
+   iinfo->numWbPages--;
+   HgfsWbRequestListRemove(req);
+   HgfsWbRequestPut(req);
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodeAddWbRequest --
+ *
+ *    Add a write-back page request to an inode.
+ *    If the page is already exists in the list for this inode nothing is
+ *    done, otherwise a new object is created for the page and added to the
+ *    inode list.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsInodePageWbAdd(struct inode *inode, // IN: inode of file to write to
+                   struct page *page)   // IN: page of data to write
+{
+   HgfsWbPage *req;
+
+   LOG(6, (KERN_CRIT "VMware hgfs: HgfsInodePageWbAdd: (%p, %p)\n",
+           inode, page));
+
+   req = HgfsInodeFindExistingWbRequest(inode, page);
+   if (req != NULL) {
+      goto exit;
+   }
+
+   /*
+    * We didn't find an existing write back request for that page so
+    * we create one.
+    */
+   req = HgfsWbRequestCreate(page);
+   if (IS_ERR(req)) {
+      goto exit;
+   }
+
+   spin_lock(&inode->i_lock);
+   /*
+    * Add the new write request for the page into our inode list to track.
+    */
+   HgfsInodeAddWbRequest(inode, req);
+   spin_unlock(&inode->i_lock);
+
+exit:
+   if (!IS_ERR(req)) {
+      HgfsWbRequestUnlockAndPut(req);
+   }
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * HgfsInodePageWbRemove --
+ *
+ *    Remove a write-back page request from an inode.
+ *
+ * Results:
+ *    None
+ *
+ * Side effects:
+ *    None
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+HgfsInodePageWbRemove(struct inode *inode, // IN: inode of file written to
+                      struct page *page)   // IN: page of data written
+{
+   HgfsWbPage *req;
+
+   LOG(6, (KERN_WARNING "VMware hgfs: HgfsInodePageWbRemove: (%p, %p)\n",
+           inode, page));
+
+   req = HgfsInodeFindExistingWbRequest(inode, page);
+   if (req == NULL) {
+      goto exit;
+   }
+   spin_lock(&inode->i_lock);
+   /*
+    * Add the new write request for the page into our inode list to track.
+    */
+   HgfsInodeRemoveWbRequest(inode, req);
+   HgfsWbRequestUnlockAndPut(req);
+   spin_unlock(&inode->i_lock);
+
+exit:
+   return;
+}
-- 
2.0.1

